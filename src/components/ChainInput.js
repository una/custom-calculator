import React, { useState, useMemo } from 'react';

function ChainInput({ chain, onCalculate }) {
  const [variableValues, setVariableValues] = useState({});
  const [error, setError] = useState('');

  // Memoize the calculation of initial variables so it only runs when the chain changes
  const initialVariables = useMemo(() => {
    if (chain.length === 0) return [];
    
    const allVars = new Set();
    const generatedResults = new Set();

    chain.forEach(func => {
      // Add all variables from the current function's definition
      func.variables.split(',').map(v => v.trim()).forEach(v => allVars.add(v));
      // Add the name of the result this function will generate
      generatedResults.add(`resultOf${func.name.replace(/\s/g, '')}`);
    });
    
    // The initial variables are those that are not generated by a previous step
    return [...allVars].filter(v => !generatedResults.has(v));
  }, [chain]);

  const handleVariableChange = (varName, value) => {
    setVariableValues(prev => ({ ...prev, [varName]: value }));
  };

  const handleCalculateClick = () => {
    const allValuesPresent = initialVariables.every(
      v => variableValues[v] !== undefined && variableValues[v] !== ''
    );

    if (!allValuesPresent) {
      setError('Please provide a value for all initial variables.');
      return;
    }
    setError('');
    onCalculate(variableValues);
  };

  if (chain.length === 0) return null;

  return (
    <div className="form-section">
      <h3>Initial Variables</h3>
      <div className="variable-inputs">
        {initialVariables.map(varName => (
          <div className="form-group" key={varName}>
            <label>{varName}</label>
            <input
              type="number"
              onChange={(e) => handleVariableChange(varName, e.target.value)}
            />
          </div>
        ))}
      </div>
      {error && <p className="error">{error}</p>}
      <button onClick={handleCalculateClick}>Calculate Chain</button>
    </div>
  );
}

export default ChainInput;